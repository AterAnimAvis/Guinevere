'use strict';

const { InterfaceMessage } = require("../util/Logger");
const { ConsoleInterface } = require("../util/ConsoleLogger");
const { DiscordInterface } = require("../discord/DiscordInterface");

const { EventEmitter } = require("events");
const { DateTime } = require("luxon");
const { Server } = require("socket.io");
const express = require("express");

require("dotenv").config();

const meta = require("../../json/meta");
const app = express()

/** 
 *  @classdesc Central Processing Core
 *  Coordinates all of the modules to extract meaning from and take action on commands.
 *  
 *  @property {EventEmitter}            coreEmitter             - The EventEmitter instance for this Core
 *  @property {number}                  corePort                - The port number for this Core to listen on
 *  @property { {String, String }[] }   registeredInterfaces    - The connected clients registered to the Core
 *  @property {InterfaceMessage}        startupMessage          - The InterfaceMessage generated by the Core startup sequence. Globally accessible.
 *  @property {InterfaceMessage}        modulesStartupMessage   - The InterfaceMessage generated by the Core's Modules startup sequences. Only accessible to Interfaces.
 * */ 
class Core {
    
    /**
     * @member {EventEmitter} coreEmitter - The EventEmitter instance for this Core
     */
    coreEmitter = new EventEmitter();

    /**
     * @member {number} corePort - The port number for this Core to listen on
     */
    corePort = 2010;

    /**
     * @member { [String, String][] } registeredInterfaces - The connected clients registered to the Core
     */
    registeredInterfaces = [];

    /**
     * @member {InterfaceMessage} startupMessage - The InterfaceMessage generated by the Core startup sequence. Globally accessible.
     */
    startupMessage = new InterfaceMessage();


    /**
     * @member {InterfaceMessage} modulesStartupMessage - The InterfaceMessage generated by the Core's Modules startup sequences. Only accessible to Interfaces.
     */
    modulesStartupMessage = new InterfaceMessage();


    /**
     * Creates a new Core. Should only be called once.
     * 
     * @constructor
     * @author Curle
     * 
     */
    constructor() {

        this.server = { };

        this.expectedInterfaces = 2;

        /**
         * 
         * Register a new Interface. 
         * 
         * @param  {String} identifier The unique name for the interface. 
         * // TODO: checking for multiple identical identifiers (ie. multiple connected apps?)
         * @param  {String} status The reported initialization status.
         */

        this.coreEmitter.on("registerInterface", (name, report) => {
            this.registeredInterfaces.push([name, report]);
            if (this.registeredInterfaces.length == this.expectedInterfaces) {
                let moduleStatus = new InterfaceMessage();
                moduleStatus.source = "Core";
                moduleStatus.destination = "console";
                moduleStatus.title("Module status").beginFormatting();

                for (const iface of this.registeredInterfaces) {
                    moduleStatus.info(iface[0]);
                    if (iface[1] == "Okay")
                        moduleStatus.success(iface[1]);
                    else
                        moduleStatus.warn(iface[1]);
                }

                moduleStatus.endFormatting();

                this.coreEmitter.emit("message", moduleStatus);
            }
        });

        this.discordInterface = new DiscordInterface(this);
        this.consoleInterface = new ConsoleInterface(this);
    }

    /**
     * Initialise and prepare processing nodes
     * @emits startup
     */

    init() {
        return new Promise(async resolve => {
            let setupMessage = new InterfaceMessage("");

            setupMessage.destination = "any";
            setupMessage.timestamp = Date.now();
            setupMessage.source = "Core"; 

            setupMessage.title("Initialization").beginFormatting().success(`Running in ${process.env.GWEN_ENV} mode.`);
            setupMessage.success(`Running version ${meta.version}.`);

            if(!Object.keys(meta.langs).includes(process.env.GWEN_LANG)) {
                process.env.GWEN_LANG = 'en-GB';
    
                setupMessage.warn(`System language not supported. Defaulting to British English. Supported langs are ${Object.keys(meta.langs)}`);
            }

            setupMessage.success(`Current Language is ${process.env.GWEN_LANG}.`);
            setupMessage.success(`Current timezone is ${DateTime.local().zoneName}.`)
            process.env.LOGGER ? setupMessage.success("Collaborative Logger Enabled") :
                                 setupMessage.warn("Collaborative Logger Disabled")
                                 .endFormatting();


            this.startupMessage = setupMessage;

            this.coreEmitter.emit("startup", setupMessage);
            
            // await this.launchListenServer(this.modulesStartupMessage);
            // await listen / connect

            resolve();
        });
    }

    /**
     * Start listening for requests on the Core port.
     * Will start a SocketIO instance, which will manage deferrring tasks.
     */
    launchListenServer() {
        return new Promise((resolve, reject) => {
            this.server = app.listen(this.corePort, (error) => {
                if(error) {
                    reject( { type: 'error', obj: error });
                    return;
                }

                let dMesg = new InterfaceMessage();
                dMesg.destination = "console";
                dMesg.source = "Core/Server"
                dMesg.title("Core").beginFormatting().success(`Started Core server at ${this.corePort}`).endFormatting();

                this.coreEmitter.emit("message", dMesg);

                const io = Server.listen(this.server);
                io.on("connection", Core.newConnection);

                resolve();
            })
        });
    }

    /**
     * Handle a new connection to the Core from an Interface.
     * Will start new instances of the central processing services,
     *  so that requests don't conflict.
     * 
     * One step closer to parallel processing of requests!
     * @param {socket} socket 
     */
    static newConnection(socket) {
        return new Promise((resolve) => {
            let connectMessage = new InterfaceMessage("").title("Core").beginFormatting();

            connectMessage.info("New client connected. Awaiting initialization signal.");

            socket.on('init', async (data) => {
                connectMessage.success(`Client connected successfully as ${data}`);
                connectMessage.success(`Client assigned ID ${socket.id}`);
                // TODO: this.coreEmitter.emit("registerInterface", data.name, socket.id);

                // TODO: hotword detection!!!
                
            })

        })
    }
}

module.exports = {
    Core
}