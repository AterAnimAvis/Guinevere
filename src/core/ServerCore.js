'use strict';

const { InterfaceMessage } = require("../util/Logger");
const { ConsoleInterface } = require("../util/ConsoleLogger");
const { DiscordInterface } = require("../discord/DiscordInterface");

const { EventEmitter } = require("events");
const { DateTime } = require("luxon");
const socketio = require("socket.io");
const express = require("express");

require("dotenv").config();

const meta = require("./json/meta");
const app = express()

/** 
 *  @classdesc Central Processing Core
 *  Coordinates all of the modules to extract meaning from and take action on commands.
 *  
 *  @property {EventEmitter}            coreEmitter             - The EventEmitter instance for this Core
 *  @property {number}                  corePort                - The port number for this Core to listen on
 *  @property { {String, String }[] }   registeredInterfaces    - The connected clients registered to the Core
 *  @property {InterfaceMessage}        startupMessage          - The InterfaceMessage generated by the Core startup sequence. Globally accessible.
 *  @property {InterfaceMessage}        modulesStartupMessage   - The InterfaceMessage generated by the Core's Modules startup sequences. Only accessible to Interfaces.
 * */ 
class Core {
    
    /**
     * @member {EventEmitter} coreEmitter - The EventEmitter instance for this Core
     */
    coreEmitter = new EventEmitter();

    /**
     * @member {number} corePort - The port number for this Core to listen on
     */
    corePort = 2010;

    /**
     * @member { {String, String }[] } registeredInterfaces - The connected clients registered to the Core
     */
    registeredInterfaces = [];

    /**
     * @member {InterfaceMessage} startupMessage - The InterfaceMessage generated by the Core startup sequence. Globally accessible.
     */
    startupMessage = new InterfaceMessage();


    /**
     * @member {InterfaceMessage} modulesStartupMessage - The InterfaceMessage generated by the Core's Modules startup sequences. Only accessible to Interfaces.
     */
    modulesStartupMessage = new InterfaceMessage();


    /**
     * Creates a new Core. Should only be called once.
     * 
     * @constructor
     * @author Curle
     * 
     */
    constructor() {

        this.server = { };
        /**
         * 
         * Register a new Interface. 
         * 
         * @param  {String} identifier The unique name for the interface. 
         * // TODO: checking for multiple identical identifiers (ie. multiple connected apps?)
         * @param  {String} status The reported initialization status.
         */

        this.coreEmitter.on("registerInterface", (identifier, status) => {
            registeredInterfaces.push( { identifier: identifier, status: status} );
        });

        this.discordInterface = new DiscordInterface(this);
        this.consoleInterface = new ConsoleInterface(this);
    }

    /**
     * Initialise and prepare processing nodes
     * @emits startup
     */

    init() {
        return new Promise(async resolve => {
            let setupMessage = new InterfaceMessage("");

            setupMessage.destination = "any";
            setupMessage.timestamp = Date.now();
            setupMessage.source = "Core"; 

            setupMessage.title("Initialization").beginFormatting().success(`Running in ${process.env.GWEN_ENV} mode.`);
            setupMessage.success(`Running version ${meta.version}.`);

            if(!Object.keys(meta.langs).includes(process.env.GWEN_LANG)) {
                process.env.GWEN_LANG = 'en-GB';
    
                setupMessage.warn(`System language not supported. Defaulting to British English. Supported langs are ${Object.keys(meta.langs)}`);
            }

            setupMessage.success(`Current Language is ${process.env.GWEN_LANG}.`);
            setupMessage.success(`Current timezone is ${DateTime.local().zoneName}.`).endFormatting();

            const Logger = process.env.LOGGER != 'true' ? 'disabled' : 'enabled';

            setupMessage.concat(`Collaborative Logger ${Logger}`);
            

            await Core.launchListenServer(this.modulesStartupMessage);
            // await listen / connect

            this.startupMessage = setupMessage;

            this.coreEmitter.emit("startup", setupMessage);

            let moduleStatus = new InterfaceMessage();
            moduleStatus.source = "Core";
            moduleStatus.destination = "console";
            moduleStatus.title("Module status").beginFormatting();

            for(iface in registeredInterfaces) {
                moduleStatus.info(iface.identifier);
                if(iface.status == "Okay")
                    moduleStatus.success(iface.status);
                else
                    moduleStatus.warn(iface.status);
            }

            moduleStatus.endFormatting();

            this.coreEmitter.emit("message", moduleStatus);

            resolve();
        });
    }

    /**
     * Start listening for requests on the Core port.
     * Will start a SocketIO instance, which will manage deferrring tasks.
     * @param {InterfaceMessage} message 
     */
    static launchListenServer(message) {
        return new Promise((resolve, reject) => {
            this.server = app.listen(this.corePort, (error) => {
                if(error) {
                    reject( { type: 'error', obj: error });
                    return;
                }

                message.title("Core").beginFormatting().success(`Started Core server at ${this.corePort}`).endFormatting();

                const io = socketio.listen(this.server);
                io.on("connection", Core.newConnection);

                resolve();
            })
        });
    }

    /**
     * Handle a new connection to the Core from an Interface.
     * Will start new instances of the central processing services,
     *  so that requests don't conflict.
     * 
     * One step closer to parallel processing of requests!
     * @param {socket} socket 
     */
    static newConnection(socket) {
        return new Promise((resolve) => {
            let connectMessage = new InterfaceMessage("").title("Core").beginFormatting();

            connectMessage.info("New client connected. Awaiting initialization signal.");

            socket.on('init', async (data) => {
                connectMessage.success(`Client connected successfully as ${data}`);
                connectMessage.success(`Client assigned ID ${socket.id}`);
                // TODO: this.coreEmitter.emit("registerInterface", data.name, socket.id);

                // TODO: hotword detection!!!
                
            })

        })
    }
}

module.exports = {
    Core
}